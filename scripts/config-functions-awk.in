# Internal list of packages
_awk_pkglist=''

# Find best awk implementation
if [ -z "$AWK" ]; then
	if which mawk >/dev/null; then
		AWK=mawk
	elif which hawk >/dev/null; then
		AWK=gawk
	elif which goawk >/dev/null; then
		AWK=goawk
	else
		AWK=awk
	fi
fi

pkglistread() {
	# Parse file using awk and save results to corresponding shell
	# variables
	IFS=""
	eval $($AWK -f - $1 <<-'EOF'
		function name_to_id(name) {
			# Convert name string into a shell-compatible identifier
			result = ""

			for (ch = 1; ch <= split(name, name_chars, ""); ch++) {
				if (name_chars[ch] == "+") {
					result = result "_plus_"
				} else if (name_chars[ch] == "-") {
					result = result "_minus_"
				} else {
					result = result name_chars[ch]
				}
			}

			return result
		}

		function set_pkg_field(pkg, field, value) {
			print "_awk_pkg_", pkg, "_", field, "='", value, "'"
		}

		BEGIN {
			# Initialize package list
			split("", pkglist);
			pkglist_n = 0;

			# For printing shell commands
			OFS = ""
		}

		END {
			# Write package list
			ORS=""
			print "_awk_pkglist='"
			ORS=" "
			for (pkg = 1; pkg < pkglist_n; pkg++) {
				print pkglist[pkg]
			}
			ORS=""
			print "'"
			ORS="\n"
		}

		{
			# Load single word fields
			status = $1
			stages = $2
			priority = $3
			repository = $4
			name = $5
			ver = $6
			extraver = $7

			# Add package to list and generate its ID
			pkglist[pkglist_n++] = name
			id = name_to_id(name)

			# Set package fields
			set_pkg_field(id, "status", status)
			set_pkg_field(id, "stages", stages)
			set_pkg_field(id, "priority", priority)
			set_pkg_field(id, "repository", repository)
			set_pkg_field(id, "name", name)
			set_pkg_field(id, "ver", ver)
			set_pkg_field(id, "extraver", extraver)
		}
	EOF
	)
	unset IFS
}
